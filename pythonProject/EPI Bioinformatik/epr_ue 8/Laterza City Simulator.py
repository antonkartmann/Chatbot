__author__ = "8304676, Kartmann, 8310275, Nuristani"

# import tkinter and messagebox for the GUI
import tkinter as tk
from tkinter import messagebox


"""
Module: Laterza City Simulation
This module implements a city simulation game where the player manages various aspects 
of a city including its resources, population classes, and overall satisfaction and 
treasury. The goal is to improve the city's satisfaction score and treasury while 
balancing different city dynamics.
"""


# Base class for various resources in the city
class CityResource:
    """
    Base class for resources in the city. Manages common attributes and actions related to
    resources such as cost, satisfaction increase, and profit generation.
    """

    def __init__(self, cost, satisfaction_increase, profit):
        """
        Initializes a Resource with specified cost, satisfaction increase, and profit.
        """
        self.cost = cost  # Cost to purchase the resource
        self.satisfaction_increase = satisfaction_increase  # Increase in satisfaction upon purchase
        self.purchased = False  # Boolean to track if the resource has been purchased
        self.profit = profit  # Profit generated by the resource

    # Method to handle purchasing of the resource
    def purchase(self, city):
        """
        Handles the purchase of the resource. Deducts cost from city's treasury and
        increases satisfaction score if sufficient funds are available.
        """
        # Check if the city treasury has enough funds
        if city.treasury >= self.cost:
            city.treasury -= self.cost  # Deduct cost from treasury
            city.satisfaction_score += self.satisfaction_increase  # Increase satisfaction score
            self.purchased = True  # Mark resource as purchased
            return True  # Successful purchase
        return False  # Purchase failed due to insufficient funds

    # Method to calculate profit for the city from this resource
    def calculate_profit(self):
        """
        Calculates the profit generated by the resource if it has been purchased.
        """
        # Profit is generated only if the resource is purchased
        if self.purchased:
            return self.profit
        else:
            return 0


# Subclasses for specific types of city resources
class SwimmingPool(CityResource):
    """
    Represents a swimming pool resource in the city. A specific type of resource
    that increases city satisfaction and generates profit.
    """
    def __init__(self):
        super().__init__(250000, 3, 20000)


class Hospital(CityResource):
    """
    Represents a hospital resource in the city. It significantly increases city satisfaction
    but has a maintenance cost.
    """
    def __init__(self):
        super().__init__(1200000, 20, -150000)


class Park(CityResource):
    """
    Represents a park resource in the city. It increases city satisfaction and has a small
    maintenance cost.
    """
    def __init__(self):
        super().__init__(140000, 5, -5000)


class Mall(CityResource):
    """
        Represents a mall resource in the city. It increases city satisfaction and generates profit.
        """
    def __init__(self):
        super().__init__(2000000, 10, 10000)


class School(CityResource):
    """
    Represents a school resource in the city, which can be upgraded. Each upgrade
    increases the satisfaction score.
    """
    def __init__(self):
        super().__init__(0, 0, 0)
        self.level = 1  # Initial level of the school

    # Overriding the purchase method for school to handle upgrades
    def purchase(self, city):
        """
        Handles the upgrading of the school. Each upgrade increases its level and
        the city's satisfaction score, costing a certain amount.
        """
        upgrade_cost = city.population * self.level * 3  # Calculating upgrade cost
        if city.treasury >= upgrade_cost and self.level < 5:
            city.treasury -= upgrade_cost
            self.level += 1  # Increment the level of the school
            city.satisfaction_score += 3 * self.level
            return True  # Upgrade successful
        return False  # Upgrade failed due to insufficient funds or max level reached


class Church(CityResource):

    """
    Represents a church resource in the city. It increases city satisfaction but has a
    maintenance cost.
    """
    def __init__(self):
        super().__init__(100000, 5, -10000)


class Mosque(CityResource):
    """
    Represents a mosque resource in the city. It increases city satisfaction but has a
    maintenance cost.
    """
    def __init__(self):
        super().__init__(100000, 5, -10000)


class Synagogue(CityResource):

    """
    Represents a synagogue resource in the city. It increases city satisfaction but has a
    maintenance cost.
    """
    def __init__(self):
        super().__init__(100000, 5, -10000)


class Nothing(CityResource):
    """
    Represents the action of doing nothing in the city. It negatively affects the city's
    satisfaction score.
    """
    def __init__(self):
        super().__init__(0, -5, 0)  # Choosing to do nothing decreases satisfaction


# Base class for different groups of people in the city
class People:
    """
    Base class for different groups of people in the city. Manages attributes and actions
    related to the city's population.
    """
    def __init__(self, total_population):
        """
        Initializes the People class with the total population of the city.
        """
        self.total_population = total_population  # Total population of the city

    def update_population(self, new_total_population):
        """
        Updates the total population of the city and recalculates the population of the specific class.
        """
        self.total_population = new_total_population  # Update the total population
        self.update_class_population()  # Update the population for the specific class

    def update_class_population(self):
        """
        Placeholder method for updating the population of a specific class. To be overridden in subclasses.
        """
        # Placeholder method to be overridden in subclasses
        pass


# Subclass representing the lower class population in the city
class LowerClass(People):
    """
    Represents the lower class population in the city. This class receives subsidies,
    impacting the city's treasury.
    """
    def __init__(self, total_population):
        super().__init__(total_population)
        self.subsidy_rate = 1  # Subsidy rate for the lower class
        self.update_class_population()  # Initialize population for the lower class

    def calculate_taxes(self):
        return -self.population * self.subsidy_rate  # Calculate the subsidy cost for lower class

    def update_class_population(self):
        self.population = int(self.total_population * 0.2)  # 20% of the total population is lower class


# Subclass representing the middle class population in the city
class MiddleClass(People):
    """
    Represents the middle class population in the city. This class contributes to the city's
    treasury through taxes.
    """
    def __init__(self, total_population):
        super().__init__(total_population)
        self.tax_rate = 3  # Tax rate for the middle class
        self.update_class_population()  # Initialize population for the middle class

    def calculate_taxes(self):
        return self.population * self.tax_rate  # Calculate tax revenue from middle class

    def update_class_population(self):
        self.population = int(self.total_population * 0.6)  # 60% of the total population is middle class


# Subclass representing the upper class population in the city
class UpperClass(People):
    """
    Represents the upper class population in the city. This class significantly contributes
    to the city's treasury through a higher tax rate.
    """
    def __init__(self, total_population):
        super().__init__(total_population)
        self.tax_rate = 7  # Tax rate for the upper class
        self.update_class_population()  # Initialize population for the upper class

    def calculate_taxes(self):
        return self.population * self.tax_rate  # Calculate tax revenue from upper class

    def update_class_population(self):
        self.population = int(self.total_population * 0.1)  # 10% of the total population is upper class


# Subclass representing civil servants in the city
class CivilServants(People):
    """
    Represents the civil servants in the city. This group incurs costs to the city's treasury
    in the form of salaries.
    """
    def __init__(self, total_population):
        super().__init__(total_population)
        self.salary_cost = 5  # Salary cost per civil servant
        self.update_class_population()  # Initialize population for civil servants

    def calculate_costs(self):
        return self.population * self.salary_cost  # Calculate total salary costs for civil servants

    def update_class_population(self):
        self.population = int(self.total_population * 0.1)  # 10% of the total population is civil servants


# Subclass representing tourists visiting the city
class Tourists(People):
    """
    Represents the tourists visiting the city. Their expenditure contributes to the city's treasury
    and is influenced by the city's satisfaction score.
    """
    def __init__(self, total_population):
        super().__init__(total_population)
        self.expenditure_rate = 0  # Initial expenditure rate for tourists

    def calculate_expenditure(self, satisfaction_score):
        # Determine expenditure rate based on city satisfaction score
        if satisfaction_score > 80:
            self.expenditure_rate = 50000  # High satisfaction leads to high expenditure
        elif satisfaction_score > 50:
            self.expenditure_rate = 30000  # Moderate satisfaction leads to medium expenditure
        else:
            self.expenditure_rate = 10000  # Low satisfaction leads to low expenditure
        return self.expenditure_rate  # Return the calculated expenditure rate


# Main class for the city simulation game
class LaterzaCitySimulation:
    """
    Represents the main game class for the Laterza City Simulation. Manages the city's
    population, treasury, satisfaction score, resources, and different population classes.
    """
    def __init__(self):
        """
        Initializes the city simulation with default values for population, treasury, satisfaction score,
        resources, and population classes.
        """
        # Initial setup of the city's attributes
        self.population = 80000  # Starting population
        self.treasury = 1000000  # Starting amount in the city treasury
        self.satisfaction_score = 50  # Initial satisfaction score of the city
        # Initialize the tourists and different resources of the city
        self.tourists = Tourists(self.population)
        self.resources = {
            'swimming_pool': SwimmingPool(),
            'hospital': Hospital(),
            'park': Park(),
            'mall': Mall(),
            'nothing': Nothing(),
            'school': School(),
            'church': Church(),
            'mosque': Mosque(),
            'synagogue': Synagogue()
        }
        # Initialize the different classes of people in the city
        self.lower_class = LowerClass(self.population)
        self.middle_class = MiddleClass(self.population)
        self.upper_class = UpperClass(self.population)
        self.civil_servants = CivilServants(self.population)
        self.people = People(self.population)

    # Method for updating the city each quarter
    def quarterly_update(self):
        """
        Performs the quarterly update of the city. Updates population classes, calculates
        tax revenue, adjusts population based on satisfaction score, and checks for
        game win/lose conditions.
        """
        # Update population classes and calculate taxes
        self.update_population_classes()
        tax_revenue = self.calculate_total_taxes()
        self.treasury += tax_revenue

        # Adjust population based on satisfaction score
        if self.satisfaction_score > 60:
            self.population += self.satisfaction_score * 100
        if self.satisfaction_score < 40:
            self.population -= int(self.population / 10)
        # Calculate profit from resources
        for resource in self.resources.values():
            self.treasury += resource.calculate_profit()
        # Check for game win or lose conditions
        if self.satisfaction_score >= 100 or self.treasury >= 10000000:
            messagebox.showinfo("Spiel Beendet", "Glückwunsch, Sie haben das Spiel gewonnen!😄")
            root.quit()
        if self.satisfaction_score <= 25 or self.treasury <= 0:
            messagebox.showinfo("Spiel Beendet", "Sie haben das Spiel verloren! Versuchen Sie es erneut!😭")
            root.quit()

        # Calculate and add tourist revenue to the treasury
        tourist_revenue = self.tourists.calculate_expenditure(self.satisfaction_score)
        self.treasury += tourist_revenue

    def update_population_classes(self):
        """
        Updates the population count for each class based on the current total population
        of the city.
        """
        # Update each class with the new population number
        self.lower_class.update_population(self.population)
        self.middle_class.update_population(self.population)
        self.upper_class.update_population(self.population)
        self.civil_servants.update_population(self.population)


    def game_status(self):
        """
        Returns the current status of the game as a formatted string, including information
        about the population, treasury, satisfaction, and more.
        """
        # Prepare the game status string with updated information
        self.update_population_classes()
        tourist_revenue = self.tourists.calculate_expenditure(self.satisfaction_score)
        return (f"Bevölkerung: {self.population}, Kassenbestand: ${self.treasury}, "
                f"Zufriedenheit: {self.satisfaction_score}, "
                f"Unterschicht: {self.lower_class.population}, "
                f"Mittelschicht: {self.middle_class.population}, "
                f"Oberschicht: {self.upper_class.population}, "
                f"Beamte: {self.civil_servants.population}, "
                f"Touristenausgaben: {tourist_revenue}€ pro Quartal ")

    def calculate_total_taxes(self):
        """
        Calculates the total tax revenue of the city by summing up the taxes from each
        population class and subtracting the costs for civil servants.
        """
        # Calculate total taxes from all population classes
        return (self.lower_class.calculate_taxes() +
                self.middle_class.calculate_taxes() +
                self.upper_class.calculate_taxes() -
                self.civil_servants.calculate_costs())


# Create an instance of the LaterzaCitySimulation
game = LaterzaCitySimulation()


# GUI Functions
def purchase_resource(resource_key):
    """
    Handles the purchase of a resource for the city. Displays appropriate messages based on
    the success or failure of the purchase and updates the game state accordingly.
    """
    # Function to handle the purchase of a resource
    resource = game.resources[resource_key]
    successful_purchase = resource.purchase(game)

    # Check if the purchase was successful
    if successful_purchase:
        # Display a message based on the type of resource purchased
        if isinstance(resource, School):
            messagebox.showinfo("Aktion durchgeführt", f"Schule auf Level {resource.level} verbessert.")
        else:
            messagebox.showinfo("Aktion durchgeführt", f"{resource_key.replace('_', ' ').title()} gekauft.")
        game.quarterly_update()  # Update the game state after purchase
        update_status()  # Update the status display
    else:
        # Display a message if purchase failed
        if resource.purchased:
            messagebox.showinfo("Aktion fehlgeschlagen", f"{resource_key.replace('_', ' ').title()} "
                                                         f"bereits gekauft oder auf maximalem Level.")
        else:
            messagebox.showinfo("Aktion fehlgeschlagen", "Nicht genug Geld.")


def update_status():
    """
    Updates the status display in the GUI with the latest game information.
    """
    # Update the status display with the latest game information
    game.update_population_classes()
    status_label.config(text=game.game_status())


def simulate_tourist_spending():
    """
    Simulates the spending of tourists in the city, updates the city's treasury, and
    reflects the changes in the game state.
    """
    # Function to simulate tourist spending and update the game state
    tourist_revenue = game.tourists.calculate_expenditure(game.satisfaction_score)
    game.treasury += tourist_revenue
    messagebox.showinfo("Touristenausgaben", f"Touristen haben {tourist_revenue}€ in der Stadt "
                                             f"ausgegeben.")
    game.quarterly_update()
    update_status()


# Setting up the main window of the application
root = tk.Tk()
root.title("LaterzaCity Simulation")


# GUI Widgets
status_label = tk.Label(root, text=game.game_status())
status_label.pack()

heading_label = tk.Label(root, text="LaterzaCity Simulation", font=("Helvetica", 16, "bold"))
heading_label.pack()


# create and pack the information label
information_label = tk.Label(root, text=("Willkommen zur LaterzaCity Simulation! "
                                   "Verwalten Sie Ihre Stadt, indem Sie Ressourcen kaufen und "
                                   "die Zufriedenheit sowie den Kassenbestand Ihrer Stadt im Auge behalten. "
                                   "Ziel ist es, eine hohe Zufriedenheit zu erreichen oder den Kassenbestand zu "
                                   "maximieren. "
                                   "Viel Erfolg!"), wraplength=400)
information_label.pack()

# Buttons for purchasing resources and taking actions in the game
swimming_pool_button = tk.Button(root, text="Schwimmbad kaufen", command=lambda: purchase_resource('swimming_pool'))
hospital_button = tk.Button(root, text="Krankenhaus kaufen", command=lambda: purchase_resource('hospital'))
park_button = tk.Button(root, text="Park kaufen", command=lambda: purchase_resource('park'))
mall_button = tk.Button(root, text="Einkaufszentrum kaufen", command=lambda: purchase_resource('mall'))
school_button = tk.Button(root, text="Schule verbessern", command=lambda: purchase_resource('school'))
church_button = tk.Button(root, text="Kirche bauen", command=lambda: purchase_resource('church'))
mosque_button = tk.Button(root, text="Moschee bauen", command=lambda: purchase_resource('mosque'))
synagogue_button = tk.Button(root, text="Synagoge bauen", command=lambda: purchase_resource('synagogue'))
nothing_button = tk.Button(root, text="Nichts tun", command=lambda: purchase_resource('nothing'))

# Packing buttons into the GUI
swimming_pool_button.pack()
hospital_button.pack()
park_button.pack()
mall_button.pack()
school_button.pack()
church_button.pack()
mosque_button.pack()
synagogue_button.pack()
nothing_button.pack()

# Run the main loop of the application
root.mainloop()
